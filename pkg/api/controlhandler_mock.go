// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package api

import (
	"context"
	"sync"
)

// Ensure, that ControlHandlerMock does implement ControlHandler.
// If this is not the case, regenerate this file with moq.
var _ ControlHandler = &ControlHandlerMock{}

// ControlHandlerMock is a mock implementation of ControlHandler.
//
//	func TestSomethingThatUsesControlHandler(t *testing.T) {
//
//		// make and configure a mocked ControlHandler
//		mockedControlHandler := &ControlHandlerMock{
//			GetStatsFunc: func(ctx context.Context) (*StatsResponse, error) {
//				panic("mock out the GetStats method")
//			},
//			GetStatusFunc: func(ctx context.Context) (*StatusResponse, error) {
//				panic("mock out the GetStatus method")
//			},
//			HandleDisableFunc: func(ctx context.Context) error {
//				panic("mock out the HandleDisable method")
//			},
//			HandleEnableFunc: func(ctx context.Context, args EnableArgs) error {
//				panic("mock out the HandleEnable method")
//			},
//			HandleReloadFunc: func(ctx context.Context, args ReloadArgs) error {
//				panic("mock out the HandleReload method")
//			},
//		}
//
//		// use mockedControlHandler in code that requires ControlHandler
//		// and then make assertions.
//
//	}
type ControlHandlerMock struct {
	// GetStatsFunc mocks the GetStats method.
	GetStatsFunc func(ctx context.Context) (*StatsResponse, error)

	// GetStatusFunc mocks the GetStatus method.
	GetStatusFunc func(ctx context.Context) (*StatusResponse, error)

	// HandleDisableFunc mocks the HandleDisable method.
	HandleDisableFunc func(ctx context.Context) error

	// HandleEnableFunc mocks the HandleEnable method.
	HandleEnableFunc func(ctx context.Context, args EnableArgs) error

	// HandleReloadFunc mocks the HandleReload method.
	HandleReloadFunc func(ctx context.Context, args ReloadArgs) error

	// calls tracks calls to the methods.
	calls struct {
		// GetStats holds details about calls to the GetStats method.
		GetStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetStatus holds details about calls to the GetStatus method.
		GetStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// HandleDisable holds details about calls to the HandleDisable method.
		HandleDisable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// HandleEnable holds details about calls to the HandleEnable method.
		HandleEnable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args EnableArgs
		}
		// HandleReload holds details about calls to the HandleReload method.
		HandleReload []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args ReloadArgs
		}
	}
	lockGetStats      sync.RWMutex
	lockGetStatus     sync.RWMutex
	lockHandleDisable sync.RWMutex
	lockHandleEnable  sync.RWMutex
	lockHandleReload  sync.RWMutex
}

// GetStats calls GetStatsFunc.
func (mock *ControlHandlerMock) GetStats(ctx context.Context) (*StatsResponse, error) {
	if mock.GetStatsFunc == nil {
		panic("ControlHandlerMock.GetStatsFunc: method is nil but ControlHandler.GetStats was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetStats.Lock()
	mock.calls.GetStats = append(mock.calls.GetStats, callInfo)
	mock.lockGetStats.Unlock()
	return mock.GetStatsFunc(ctx)
}

// GetStatsCalls gets all the calls that were made to GetStats.
// Check the length with:
//
//	len(mockedControlHandler.GetStatsCalls())
func (mock *ControlHandlerMock) GetStatsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetStats.RLock()
	calls = mock.calls.GetStats
	mock.lockGetStats.RUnlock()
	return calls
}

// GetStatus calls GetStatusFunc.
func (mock *ControlHandlerMock) GetStatus(ctx context.Context) (*StatusResponse, error) {
	if mock.GetStatusFunc == nil {
		panic("ControlHandlerMock.GetStatusFunc: method is nil but ControlHandler.GetStatus was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetStatus.Lock()
	mock.calls.GetStatus = append(mock.calls.GetStatus, callInfo)
	mock.lockGetStatus.Unlock()
	return mock.GetStatusFunc(ctx)
}

// GetStatusCalls gets all the calls that were made to GetStatus.
// Check the length with:
//
//	len(mockedControlHandler.GetStatusCalls())
func (mock *ControlHandlerMock) GetStatusCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetStatus.RLock()
	calls = mock.calls.GetStatus
	mock.lockGetStatus.RUnlock()
	return calls
}

// HandleDisable calls HandleDisableFunc.
func (mock *ControlHandlerMock) HandleDisable(ctx context.Context) error {
	if mock.HandleDisableFunc == nil {
		panic("ControlHandlerMock.HandleDisableFunc: method is nil but ControlHandler.HandleDisable was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockHandleDisable.Lock()
	mock.calls.HandleDisable = append(mock.calls.HandleDisable, callInfo)
	mock.lockHandleDisable.Unlock()
	return mock.HandleDisableFunc(ctx)
}

// HandleDisableCalls gets all the calls that were made to HandleDisable.
// Check the length with:
//
//	len(mockedControlHandler.HandleDisableCalls())
func (mock *ControlHandlerMock) HandleDisableCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockHandleDisable.RLock()
	calls = mock.calls.HandleDisable
	mock.lockHandleDisable.RUnlock()
	return calls
}

// HandleEnable calls HandleEnableFunc.
func (mock *ControlHandlerMock) HandleEnable(ctx context.Context, args EnableArgs) error {
	if mock.HandleEnableFunc == nil {
		panic("ControlHandlerMock.HandleEnableFunc: method is nil but ControlHandler.HandleEnable was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Args EnableArgs
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockHandleEnable.Lock()
	mock.calls.HandleEnable = append(mock.calls.HandleEnable, callInfo)
	mock.lockHandleEnable.Unlock()
	return mock.HandleEnableFunc(ctx, args)
}

// HandleEnableCalls gets all the calls that were made to HandleEnable.
// Check the length with:
//
//	len(mockedControlHandler.HandleEnableCalls())
func (mock *ControlHandlerMock) HandleEnableCalls() []struct {
	Ctx  context.Context
	Args EnableArgs
} {
	var calls []struct {
		Ctx  context.Context
		Args EnableArgs
	}
	mock.lockHandleEnable.RLock()
	calls = mock.calls.HandleEnable
	mock.lockHandleEnable.RUnlock()
	return calls
}

// HandleReload calls HandleReloadFunc.
func (mock *ControlHandlerMock) HandleReload(ctx context.Context, args ReloadArgs) error {
	if mock.HandleReloadFunc == nil {
		panic("ControlHandlerMock.HandleReloadFunc: method is nil but ControlHandler.HandleReload was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Args ReloadArgs
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockHandleReload.Lock()
	mock.calls.HandleReload = append(mock.calls.HandleReload, callInfo)
	mock.lockHandleReload.Unlock()
	return mock.HandleReloadFunc(ctx, args)
}

// HandleReloadCalls gets all the calls that were made to HandleReload.
// Check the length with:
//
//	len(mockedControlHandler.HandleReloadCalls())
func (mock *ControlHandlerMock) HandleReloadCalls() []struct {
	Ctx  context.Context
	Args ReloadArgs
} {
	var calls []struct {
		Ctx  context.Context
		Args ReloadArgs
	}
	mock.lockHandleReload.RLock()
	calls = mock.calls.HandleReload
	mock.lockHandleReload.RUnlock()
	return calls
}
